<div class="RichText ztext Post-RichText"><p>本文搬运于个人博客，欢迎点击 <a href="https://link.zhihu.com/?target=https%3A//borgwang.github.io/ml/2019/07/28/loss-functions-in-ml.html" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">这里</a> 查看原博文。</p><p class="ztext-empty-paragraph"><br></p><p>机器学习中的监督学习本质上是给定一系列训练样本  <img src="https://www.zhihu.com/equation?tex=%28x_i%2C+y_i%29" alt="[公式]" eeimg="1" data-formula="(x_i, y_i)"> ，尝试学习  <img src="https://www.zhihu.com/equation?tex=x%5Crightarrow+y" alt="[公式]" eeimg="1" data-formula="x\rightarrow y">  的映射关系，使得给定一个  <img src="https://www.zhihu.com/equation?tex=x" alt="[公式]" eeimg="1" data-formula="x"> ，即便这个 <img src="https://www.zhihu.com/equation?tex=x" alt="[公式]" eeimg="1" data-formula="x"> 不在训练样本中，也能够得到尽量接近真实  <img src="https://www.zhihu.com/equation?tex=y" alt="[公式]" eeimg="1" data-formula="y">  的输出  <img src="https://www.zhihu.com/equation?tex=%5Chat%7By%7D" alt="[公式]" eeimg="1" data-formula="\hat{y}"> 。而损失函数（Loss Function）则是这个过程中关键的一个组成部分，用来<b>衡量模型的输出 </b> <img src="https://www.zhihu.com/equation?tex=%5Chat%7By%7D" alt="[公式]" eeimg="1" data-formula="\hat{y}"> <b> 与真实的 </b><img src="https://www.zhihu.com/equation?tex=y" alt="[公式]" eeimg="1" data-formula="y"><b> 之间的差距</b>，给模型的优化指明方向。</p><p>本文将介绍机器学习、深度学习中分类与回归常用的几种损失函数，包括均方差损失 Mean Squared Loss、平均绝对误差损失 Mean Absolute Error Loss、Huber Loss、分位数损失 Quantile Loss、交叉熵损失函数 Cross Entropy Loss、Hinge 损失 Hinge Loss。主要介绍各种损失函数的基本形式、原理、特点等方面。</p><p class="ztext-empty-paragraph"><br></p><h3>目录</h3><ol><li> 前言</li><li>均方差损失 Mean Squared Error Loss</li><li>平均绝对误差损失 Mean Absolute Error Loss</li><li>Huber Loss</li><li>分位数损失 Quantile Loss</li><li>交叉熵损失 Cross Entropy Loss</li><li>合页损失 Hinge Loss</li><li>总结</li></ol><hr><h2>前言</h2><p>在正文开始之前，先说下关于 Loss Function、Cost Function 和 Objective Function 的区别和联系。在机器学习的语境下这三个术语经常被交叉使用。 </p><ul><li>- 损失函数  Loss Function 通常是<b>针对单个训练样本而言</b>，给定一个模型输出  <img src="https://www.zhihu.com/equation?tex=%5Chat%7By%7D" alt="[公式]" eeimg="1" data-formula="\hat{y}">  和一个真实  <img src="https://www.zhihu.com/equation?tex=y" alt="[公式]" eeimg="1" data-formula="y"> ，损失函数输出一个实值损失  <img src="https://www.zhihu.com/equation?tex=L%3Df%28y_i%2C+%5Chat%7By_i%7D%29" alt="[公式]" eeimg="1" data-formula="L=f(y_i, \hat{y_i})"> </li><li>- 代价函数 Cost Function 通常是<b>针对整个训练集</b>（或者在使用 mini-batch gradient descent 时一个 mini-batch）的总损失 <img src="https://www.zhihu.com/equation?tex=J%3D%5Csum_%7Bi%3D1%7D%5E%7BN%7D+f%28y_i%2C%5Chat%7By_i%7D%29" alt="[公式]" eeimg="1" data-formula="J=\sum_{i=1}^{N} f(y_i,\hat{y_i})"> </li><li>- 目标函数 Objective Function 是一个更通用的术语，表示任意希望被优化的函数，用于机器学习领域和非机器学习领域（比如运筹优化）</li></ul><p>一句话总结三者的关系就是：<a href="https://link.zhihu.com/?target=https%3A//stats.stackexchange.com/questions/179026/objective-function-cost-function-loss-function-are-they-the-same-thing" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">A loss function is a part of a cost function which is a type of an objective function.</a></p><p>由于损失函数和代价函数只是在针对样本集上有区别，因此在本文中统一使用了损失函数这个术语，但下文的相关公式实际上采用的是代价函数 Cost Function 的形式，请读者自行留意。</p><p class="ztext-empty-paragraph"><br></p><h2>均方差损失 Mean Squared Error Loss</h2><h3><b>基本形式与原理</b></h3><p>均方差 <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Mean_squared_error" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">Mean Squared Error (MSE)</a> 损失是机器学习、深度学习回归任务中最常用的一种损失函数，也称为 L2 Loss。其基本形式如下</p><p><img src="https://www.zhihu.com/equation?tex=J_%7BMSE%7D+%3D+%5Cfrac%7B1%7D%7BN%7D%5Csum_%7Bi%3D1%7D%5E%7BN%7D%28y_i+-+%5Chat%7By_i%7D%29%5E2+%5C%5C" alt="[公式]" eeimg="1" data-formula="J_{MSE} = \frac{1}{N}\sum_{i=1}^{N}(y_i - \hat{y_i})^2 \\"></p><p>从直觉上理解均方差损失，这个损失函数的最小值为 0（当预测等于真实值时），最大值为无穷大。下图是对于真实值  <img src="https://www.zhihu.com/equation?tex=y%3D0" alt="[公式]" eeimg="1" data-formula="y=0">  ，不同的预测值 <img src="https://www.zhihu.com/equation?tex=%5B-1.5%2C+1.5%5D" alt="[公式]" eeimg="1" data-formula="[-1.5, 1.5]"> 的均方差损失的变化图。横轴是不同的预测值，纵轴是均方差损失，可以看到随着预测与真实值绝对误差 <img src="https://www.zhihu.com/equation?tex=%5Clvert+y-+%5Chat%7By%7D%5Crvert" alt="[公式]" eeimg="1" data-formula="\lvert y- \hat{y}\rvert"> 的增加，均方差损失呈二次方地增加。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-f13a4355c21d16cad8b3f30e8a24b5cc_b.jpg" data-caption="" data-size="normal" data-rawwidth="444" data-rawheight="276" class="origin_image zh-lightbox-thumb" width="444" data-original="https://pic1.zhimg.com/v2-f13a4355c21d16cad8b3f30e8a24b5cc_r.jpg"/></noscript><img src="https://pic1.zhimg.com/80/v2-f13a4355c21d16cad8b3f30e8a24b5cc_1440w.jpg" data-caption="" data-size="normal" data-rawwidth="444" data-rawheight="276" class="origin_image zh-lightbox-thumb lazy" width="444" data-original="https://pic1.zhimg.com/v2-f13a4355c21d16cad8b3f30e8a24b5cc_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-f13a4355c21d16cad8b3f30e8a24b5cc_b.jpg" data-lazy-status="ok"></figure><h3>背后的假设</h3><p>实际上在一定的假设下，我们可以使用最大化似然得到均方差损失的形式。假设<b>模型预测与真实值之间的误差服从标准高斯分布</b>（ <img src="https://www.zhihu.com/equation?tex=%5Cmu%3D0%2C+%5Csigma%3D1" alt="[公式]" eeimg="1" data-formula="\mu=0, \sigma=1"> ），则给定一个  <img src="https://www.zhihu.com/equation?tex=x_i" alt="[公式]" eeimg="1" data-formula="x_i">  模型输出真实值  <img src="https://www.zhihu.com/equation?tex=y_i" alt="[公式]" eeimg="1" data-formula="y_i">  的概率为</p><p><img src="https://www.zhihu.com/equation?tex=p%28y_i%7Cx_i%29+%3D+%5Cfrac%7B1%7D%7B%5Csqrt%7B2%5Cpi%7D%7D%5Cmathbb%7Bexp%7D%28-%5Cfrac%7B%28y_i-%5Chat%7By_i%7D%29%5E2%7D%7B2%7D%29+%5C%5C" alt="[公式]" eeimg="1" data-formula="p(y_i|x_i) = \frac{1}{\sqrt{2\pi}}\mathbb{exp}(-\frac{(y_i-\hat{y_i})^2}{2}) \\"></p><p>进一步我们假设数据集中 N 个样本点之间相互独立，则给定所有 <img src="https://www.zhihu.com/equation?tex=x" alt="[公式]" eeimg="1" data-formula="x"> 输出所有真实值 <img src="https://www.zhihu.com/equation?tex=y" alt="[公式]" eeimg="1" data-formula="y"> 的概率，即似然 Likelihood，为所有 <img src="https://www.zhihu.com/equation?tex=p%28y_i+%5Cvert+x_i%29" alt="[公式]" eeimg="1" data-formula="p(y_i \vert x_i)"> 的累乘</p><p><img src="https://www.zhihu.com/equation?tex=L%28x%2C+y%29+%3D+%5Cprod_%7Bi%3D1%7D%5E%7BN%7D%5Cfrac%7B1%7D%7B%5Csqrt%7B2%5Cpi%7D%7D%5Cmathbb%7Bexp%7D%28-%5Cfrac%7B%28y_i-%5Chat%7By_i%7D%29%5E2%7D%7B2%7D%29+%5C%5C" alt="[公式]" eeimg="1" data-formula="L(x, y) = \prod_{i=1}^{N}\frac{1}{\sqrt{2\pi}}\mathbb{exp}(-\frac{(y_i-\hat{y_i})^2}{2}) \\"></p><p>通常为了计算方便，我们通常最大化对数似然 Log-Likelihood</p><p><img src="https://www.zhihu.com/equation?tex=LL%28x%2C+y%29%3D%5Cmathbb%7Blog%7D%28L%28x%2C+y%29%29%3D-%5Cfrac%7BN%7D%7B2%7D%5Cmathbb%7Blog%7D2%5Cpi+-+%5Cfrac%7B1%7D%7B2%7D+%5Csum_%7Bi%3D1%7D%5E%7BN%7D+%28y_i-%5Chat%7By_i%7D%29%5E2+%5C%5C" alt="[公式]" eeimg="1" data-formula="LL(x, y)=\mathbb{log}(L(x, y))=-\frac{N}{2}\mathbb{log}2\pi - \frac{1}{2} \sum_{i=1}^{N} (y_i-\hat{y_i})^2 \\"></p><p>去掉与  <img src="https://www.zhihu.com/equation?tex=%5Chat%7By_i%7D" alt="[公式]" eeimg="1" data-formula="\hat{y_i}">  无关的第一项，然后转化为最小化负对数似然 Negative Log-Likelihood</p><p><img src="https://www.zhihu.com/equation?tex=NLL%28x%2C+y%29+%3D+%5Cfrac%7B1%7D%7B2%7D%5Csum_%7Bi%3D1%7D%5E%7BN%7D%28y_i+-+%5Chat%7By_i%7D%29%5E2+%5C%5C" alt="[公式]" eeimg="1" data-formula="NLL(x, y) = \frac{1}{2}\sum_{i=1}^{N}(y_i - \hat{y_i})^2 \\"></p><p>可以看到这个实际上就是均方差损失的形式。也就是说<b>在模型输出与真实值的误差服从高斯分布的假设下，最小化均方差损失函数与极大似然估计本质上是一致的</b>，因此在这个假设能被满足的场景中（比如回归），均方差损失是一个很好的损失函数选择；当这个假设没能被满足的场景中（比如分类），均方差损失不是一个好的选择。</p><p class="ztext-empty-paragraph"><br></p><h2>平均绝对误差损失 Mean Absolute Error Loss</h2><h3>基本形式与原理</h3><p>平均绝对误差 <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Mean_absolute_error" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">Mean Absolute Error (MAE)</a> 是另一类常用的损失函数，也称为 L1 Loss。其基本形式如下  </p><p><img src="https://www.zhihu.com/equation?tex=+J_%7BMAE%7D%3D%5Cfrac%7B1%7D%7BN%7D%5Csum_%7Bi%3D1%7D%5E%7BN%7D%5Cleft+%7C+y_i+-+%5Chat%7By_i%7D+%5Cright+%7C+%5C%5C" alt="[公式]" eeimg="1" data-formula=" J_{MAE}=\frac{1}{N}\sum_{i=1}^{N}\left | y_i - \hat{y_i} \right | \\"> </p><p>同样的我们可以对这个损失函数进行可视化如下图，MAE 损失的最小值为 0（当预测等于真实值时），最大值为无穷大。可以看到随着预测与真实值绝对误差  <img src="https://www.zhihu.com/equation?tex=%5Clvert+y-+%5Chat%7By%7D%5Crvert" alt="[公式]" eeimg="1" data-formula="\lvert y- \hat{y}\rvert">  的增加，MAE 损失呈线性增长</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-fd248542b6b5aa9fadcab44340045dee_b.jpg" data-caption="" data-size="normal" data-rawwidth="456" data-rawheight="276" class="origin_image zh-lightbox-thumb" width="456" data-original="https://pic3.zhimg.com/v2-fd248542b6b5aa9fadcab44340045dee_r.jpg"/></noscript><img src="https://pic3.zhimg.com/80/v2-fd248542b6b5aa9fadcab44340045dee_1440w.jpg" data-caption="" data-size="normal" data-rawwidth="456" data-rawheight="276" class="origin_image zh-lightbox-thumb lazy" width="456" data-original="https://pic3.zhimg.com/v2-fd248542b6b5aa9fadcab44340045dee_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-fd248542b6b5aa9fadcab44340045dee_b.jpg" data-lazy-status="ok"></figure><p class="ztext-empty-paragraph"><br></p><h3>背后的假设</h3><p>同样的我们可以在一定的假设下通过最大化似然得到 MAE 损失的形式，假设<b>模型预测与真实值之间的误差服从拉普拉斯分布 Laplace distribution</b>（ <img src="https://www.zhihu.com/equation?tex=%5Cmu%3D0%2C+b%3D1" alt="[公式]" eeimg="1" data-formula="\mu=0, b=1"> ），则给定一个  <img src="https://www.zhihu.com/equation?tex=x_i" alt="[公式]" eeimg="1" data-formula="x_i">  模型输出真实值  <img src="https://www.zhihu.com/equation?tex=y_i" alt="[公式]" eeimg="1" data-formula="y_i">  的概率为</p><p><img src="https://www.zhihu.com/equation?tex=p%28y_i%7Cx_i%29+%3D+%5Cfrac%7B1%7D%7B2%7D%5Cmathbb%7Bexp%7D%28-%5Cleft+%7Cy_i-%5Chat%7By_i%7D%5Cright%7C%29+%5C%5C" alt="[公式]" eeimg="1" data-formula="p(y_i|x_i) = \frac{1}{2}\mathbb{exp}(-\left |y_i-\hat{y_i}\right|) \\"> </p><p>与上面推导 MSE 时类似，我们可以得到的负对数似然实际上就是 MAE 损失的形式</p><p><img src="https://www.zhihu.com/equation?tex=L%28x%2C+y%29+%3D+%5Cprod_%7Bi%3D1%7D%5E%7BN%7D%5Cfrac%7B1%7D%7B2%7D%5Cmathbb%7Bexp%7D%28-%7Cy_i-%5Chat%7By_i%7D%7C%29%5C%5C+++LL%28x%2C+y%29+%3D+-%5Cfrac%7BN%7D%7B2%7D+-+%5Csum_%7Bi%3D1%7D%5E%7BN%7D+%7Cy_i-%5Chat%7By_i%7D%7C+%5C%5C+++NLL%28x%2C+y%29+%3D+%5Csum_%7Bi%3D1%7D%5E%7BN%7D+%7Cy_i-%5Chat%7By_i%7D%7C++%5C%5C" alt="[公式]" eeimg="1" data-formula="L(x, y) = \prod_{i=1}^{N}\frac{1}{2}\mathbb{exp}(-|y_i-\hat{y_i}|)\\   LL(x, y) = -\frac{N}{2} - \sum_{i=1}^{N} |y_i-\hat{y_i}| \\   NLL(x, y) = \sum_{i=1}^{N} |y_i-\hat{y_i}|  \\"></p><p class="ztext-empty-paragraph"><br></p><h3>MAE 与 MSE 区别</h3><p>MAE 和 MSE 作为损失函数的主要区别是：MSE 损失相比 MAE 通常可以更快地收敛，但 MAE 损失对于 outlier 更加健壮，即更加不易受到 outlier 影响。</p><p><b>MSE 通常比 MAE 可以更快地收敛</b>。当使用梯度下降算法时，MSE 损失的梯度为 <img src="https://www.zhihu.com/equation?tex=-%5Chat%7By_i%7D" alt="[公式]" eeimg="1" data-formula="-\hat{y_i}"> ，而 MAE 损失的梯度为 <img src="https://www.zhihu.com/equation?tex=%5Cpm1" alt="[公式]" eeimg="1" data-formula="\pm1"> ，即 MSE 的梯度的 scale 会随误差大小变化，而 MAE 的梯度的 scale 则一直保持为 1，即便在绝对误差  <img src="https://www.zhihu.com/equation?tex=%5Clvert+y_i-%5Chat%7By_i%7D+%5Crvert" alt="[公式]" eeimg="1" data-formula="\lvert y_i-\hat{y_i} \rvert">  很小的时候 MAE 的梯度 scale 也同样为 1，这实际上是非常不利于模型的训练的。当然你可以通过在训练过程中动态调整学习率缓解这个问题，但是总的来说，损失函数梯度之间的差异导致了 MSE 在大部分时候比 MAE 收敛地更快。这个也是 MSE 更为流行的原因。</p><p><b>MAE 对于 outlier 更加 robust</b>。我们可以从两个角度来理解这一点：</p><ul><li>第一个角度是直观地理解，下图是 MAE 和 MSE 损失画到同一张图里面，由于MAE 损失与绝对误差之间是线性关系，MSE 损失与误差是平方关系，当误差非常大的时候，MSE 损失会远远大于 MAE 损失。因此当数据中出现一个误差非常大的 outlier 时，MSE 会产生一个非常大的损失，对模型的训练会产生较大的影响。</li></ul><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-c8edffe0406dafae41a042e412cd3251_b.jpg" data-caption="" data-size="normal" data-rawwidth="838" data-rawheight="275" class="origin_image zh-lightbox-thumb" width="838" data-original="https://pic2.zhimg.com/v2-c8edffe0406dafae41a042e412cd3251_r.jpg"/></noscript><img src="https://pic2.zhimg.com/80/v2-c8edffe0406dafae41a042e412cd3251_1440w.jpg" data-caption="" data-size="normal" data-rawwidth="838" data-rawheight="275" class="origin_image zh-lightbox-thumb lazy" width="838" data-original="https://pic2.zhimg.com/v2-c8edffe0406dafae41a042e412cd3251_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-c8edffe0406dafae41a042e412cd3251_b.jpg" data-lazy-status="ok"></figure><ul><li>第二个角度是从两个损失函数的假设出发，MSE 假设了误差服从高斯分布，MAE 假设了误差服从拉普拉斯分布。拉普拉斯分布本身对于 outlier 更加 robust。参考下图（来源：<a href="https://link.zhihu.com/?target=https%3A//www.cs.ubc.ca/~murphyk/MLbook/" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">Machine Learning: A Probabilistic Perspective</a> 2.4.3 The Laplace distribution Figure 2.8），当右图右侧出现了 outliers 时，拉普拉斯分布相比高斯分布受到的影响要小很多。因此以拉普拉斯分布为假设的 MAE 对 outlier 比高斯分布为假设的 MSE 更加 robust。</li></ul><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-93ad65845f5b0dc0327fde4ded661804_b.jpg" data-caption="" data-size="normal" data-rawwidth="1007" data-rawheight="422" class="origin_image zh-lightbox-thumb" width="1007" data-original="https://pic1.zhimg.com/v2-93ad65845f5b0dc0327fde4ded661804_r.jpg"/></noscript><img src="https://pic1.zhimg.com/80/v2-93ad65845f5b0dc0327fde4ded661804_1440w.jpg" data-caption="" data-size="normal" data-rawwidth="1007" data-rawheight="422" class="origin_image zh-lightbox-thumb lazy" width="1007" data-original="https://pic1.zhimg.com/v2-93ad65845f5b0dc0327fde4ded661804_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-93ad65845f5b0dc0327fde4ded661804_b.jpg" data-lazy-status="ok"></figure><p class="ztext-empty-paragraph"><br></p><h2>Huber Loss</h2><p>上文我们分别介绍了 MSE 和 MAE 损失以及各自的优缺点，MSE 损失收敛快但容易受 outlier 影响，MAE 对 outlier 更加健壮但是收敛慢，<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Huber_loss" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">Huber Loss</a> 则是一种将 MSE 与 MAE 结合起来，取两者优点的损失函数，也被称作 Smooth Mean Absolute Error Loss 。其原理很简单，就是在误差接近 0 时使用 MSE，误差较大时使用 MAE，公式为</p><p><img src="https://www.zhihu.com/equation?tex=J_%7Bhuber%7D%3D%5Cfrac%7B1%7D%7BN%7D%5Csum_%7Bi%3D1%7D%5EN%5Cmathbb%7BI%7D_%7B%7C+y_i+-+%5Chat%7By_i%7D%7C+%5Cleq+%5Cdelta%7D+%5Cfrac%7B%28y_i+-+%5Chat%7By_i%7D%29%5E2%7D%7B2%7D%2B+%5Cmathbb%7BI%7D_%7B%7C+y_i+-+%5Chat%7By_i%7D%7C+%3E+%5Cdelta%7D+%28%5Cdelta+%7Cy_i+-+%5Chat%7By_i%7D%7C+-+%5Cfrac%7B1%7D%7B2%7D%5Cdelta%5E2%29+%5C%5C" alt="[公式]" eeimg="1" data-formula="J_{huber}=\frac{1}{N}\sum_{i=1}^N\mathbb{I}_{| y_i - \hat{y_i}| \leq \delta} \frac{(y_i - \hat{y_i})^2}{2}+ \mathbb{I}_{| y_i - \hat{y_i}| > \delta} (\delta |y_i - \hat{y_i}| - \frac{1}{2}\delta^2) \\"></p><p>上式中 <img src="https://www.zhihu.com/equation?tex=%5Cdelta" alt="[公式]" eeimg="1" data-formula="\delta"> 是 Huber Loss 的一个超参数，<img src="https://www.zhihu.com/equation?tex=%5Cdelta" alt="[公式]" eeimg="1" data-formula="\delta"> 的值是 MSE 和 MAE 两个损失连接的位置。上式等号右边第一项是 MSE 的部分，第二项是 MAE 部分，在 MAE 的部分公式为  <img src="https://www.zhihu.com/equation?tex=%5Cdelta+%5Clvert+y_i+-+%5Chat%7By_i%7D%5Crvert+-+%5Cfrac%7B1%7D%7B2%7D%5Cdelta%5E2" alt="[公式]" eeimg="1" data-formula="\delta \lvert y_i - \hat{y_i}\rvert - \frac{1}{2}\delta^2">  是为了保证误差 <img src="https://www.zhihu.com/equation?tex=%5Clvert+y+-+%5Chat%7By%7D%5Crvert%3D%5Cpm+%5Cdelta" alt="[公式]" eeimg="1" data-formula="\lvert y - \hat{y}\rvert=\pm \delta"> 时 MAE 和 MSE 的取值一致，进而保证 Huber Loss 损失连续可导。</p><p>下图是  <img src="https://www.zhihu.com/equation?tex=%5Cdelta%3D1.0" alt="[公式]" eeimg="1" data-formula="\delta=1.0">  时的 Huber Loss，可以看到在  <img src="https://www.zhihu.com/equation?tex=%5B-%5Cdelta%2C+%5Cdelta%5D" alt="[公式]" eeimg="1" data-formula="[-\delta, \delta]">  的区间内实际上就是 MSE 损失，在  <img src="https://www.zhihu.com/equation?tex=%28-%5Cinfty%2C+%5Cdelta%29" alt="[公式]" eeimg="1" data-formula="(-\infty, \delta)">  和  <img src="https://www.zhihu.com/equation?tex=%28%5Cdelta%2C+%5Cinfty%29" alt="[公式]" eeimg="1" data-formula="(\delta, \infty)">  区间内为 MAE损失。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-b4260d38f70dd920fa46b8717596bda7_b.jpg" data-caption="" data-size="normal" data-rawwidth="442" data-rawheight="272" class="origin_image zh-lightbox-thumb" width="442" data-original="https://pic4.zhimg.com/v2-b4260d38f70dd920fa46b8717596bda7_r.jpg"/></noscript><img src="https://pic4.zhimg.com/80/v2-b4260d38f70dd920fa46b8717596bda7_1440w.jpg" data-caption="" data-size="normal" data-rawwidth="442" data-rawheight="272" class="origin_image zh-lightbox-thumb lazy" width="442" data-original="https://pic4.zhimg.com/v2-b4260d38f70dd920fa46b8717596bda7_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-b4260d38f70dd920fa46b8717596bda7_b.jpg" data-lazy-status="ok"></figure><h3>Huber Loss 的特点</h3><p>Huber Loss 结合了 MSE 和 MAE 损失，在误差接近 0 时使用 MSE，使损失函数可导并且梯度更加稳定；在误差较大时使用 MAE 可以降低 outlier 的影响，使训练对 outlier 更加健壮。缺点是需要额外地设置一个  <img src="https://www.zhihu.com/equation?tex=%5Cdelta" alt="[公式]" eeimg="1" data-formula="\delta">  超参数。</p><p class="ztext-empty-paragraph"><br></p><h2>分位数损失 Quantile Loss</h2><p>分位数回归 <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Quantile_regression" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">Quantile Regression</a> 是一类在实际应用中非常有用的回归算法，通常的回归算法是拟合目标值的期望或者中位数，而分位数回归可以通过给定不同的分位点，拟合目标值的不同分位数。例如我们可以分别拟合出多个分位点，得到一个置信区间，如下图所示（图片来自笔者的一个分位数回归代码 demo <a href="https://link.zhihu.com/?target=https%3A//gist.github.com/borgwang/4313e9375ef233c3b812f9f80f1af2bb" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">Quantile Regression Demo</a>）</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-8eb8ecfcdd8031a16a471905217934a0_b.jpg" data-caption="" data-size="normal" data-rawwidth="424" data-rawheight="264" class="origin_image zh-lightbox-thumb" width="424" data-original="https://pic1.zhimg.com/v2-8eb8ecfcdd8031a16a471905217934a0_r.jpg"/></noscript><img src="https://pic1.zhimg.com/80/v2-8eb8ecfcdd8031a16a471905217934a0_1440w.jpg" data-caption="" data-size="normal" data-rawwidth="424" data-rawheight="264" class="origin_image zh-lightbox-thumb lazy" width="424" data-original="https://pic1.zhimg.com/v2-8eb8ecfcdd8031a16a471905217934a0_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-8eb8ecfcdd8031a16a471905217934a0_b.jpg" data-lazy-status="ok"></figure><p>分位数回归是通过使用分位数损失 Quantile Loss 来实现这一点的，分位数损失形式如下，式中的 r 分位数系数。</p><p><img src="https://www.zhihu.com/equation?tex=J_%7Bquant%7D+%3D+%5Cfrac%7B1%7D%7BN%7D%5Csum_%7Bi%3D1%7D%5E%7BN%7D+%5Cmathbb%7BI%7D_%7B%5Chat%7By_i%7D%5Cgeq+y_i%7D%281-r%29%7Cy_i+-+%5Chat%7By_i%7D%7C+%2B+%5Cmathbb%7BI%7D_%7B%5Chat%7By_i%7D%3C+y_i%7Dr%7Cy_i-%5Chat%7By_i%7D%7C+%5C%5C" alt="[公式]" eeimg="1" data-formula="J_{quant} = \frac{1}{N}\sum_{i=1}^{N} \mathbb{I}_{\hat{y_i}\geq y_i}(1-r)|y_i - \hat{y_i}| + \mathbb{I}_{\hat{y_i}< y_i}r|y_i-\hat{y_i}| \\"> </p><p>我们如何理解这个损失函数呢？这个损失函数是一个分段的函数 ，将 <img src="https://www.zhihu.com/equation?tex=%5Chat%7By_i%7D+%5Cgeq+y_i" alt="[公式]" eeimg="1" data-formula="\hat{y_i} \geq y_i"> （高估） 和  <img src="https://www.zhihu.com/equation?tex=%5Chat%7By_i%7D+%3C+y_i" alt="[公式]" eeimg="1" data-formula="\hat{y_i} < y_i"> （低估） 两种情况分开来，并分别给予不同的系数。当  <img src="https://www.zhihu.com/equation?tex=r%3E0.5" alt="[公式]" eeimg="1" data-formula="r>0.5">  时，低估的损失要比高估的损失更大，反过来当  <img src="https://www.zhihu.com/equation?tex=r+%3C+0.5" alt="[公式]" eeimg="1" data-formula="r < 0.5">  时，高估的损失比低估的损失大；分位数损失实现了<b>分别用不同的系数控制高估和低估的损失，进而实现分位数回归</b>。特别地，当  <img src="https://www.zhihu.com/equation?tex=r%3D0.5" alt="[公式]" eeimg="1" data-formula="r=0.5">  时，分位数损失退化为 MAE 损失，从这里可以看出 MAE 损失实际上是分位数损失的一个特例 — 中位数回归（这也可以解释为什么 MAE 损失对 outlier 更鲁棒：MSE 回归期望值，MAE 回归中位数，通常 outlier 对中位数的影响比对期望值的影响小）。</p><p><img src="https://www.zhihu.com/equation?tex=J_%7Bquant%7D%5E%7Br%3D0.5%7D+%3D+%5Cfrac%7B1%7D%7BN%7D%5Csum_%7Bi%3D1%7D%5E%7BN%7D%5Cleft+%7C+y_i+-+%5Chat%7By_i%7D+%5Cright+%7C+%5C%5C+" alt="[公式]" eeimg="1" data-formula="J_{quant}^{r=0.5} = \frac{1}{N}\sum_{i=1}^{N}\left | y_i - \hat{y_i} \right | \\ "> </p><p>下图是取不同的分位点 <img src="https://www.zhihu.com/equation?tex=%5B0.25%2C+0.5%2C+0.75%5D" alt="[公式]" eeimg="1" data-formula="[0.25, 0.5, 0.75]"> 得到的三个不同的分位损失函数的可视化，可以看到 0.2 和 0.6 在高估和低估两种情况下损失是不同的，而 0.5 实际上就是 MAE。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-f8ed385f32a517c784bce841e6da1daf_b.jpg" data-caption="" data-size="normal" data-rawwidth="460" data-rawheight="270" class="origin_image zh-lightbox-thumb" width="460" data-original="https://pic4.zhimg.com/v2-f8ed385f32a517c784bce841e6da1daf_r.jpg"/></noscript><img src="https://pic4.zhimg.com/80/v2-f8ed385f32a517c784bce841e6da1daf_1440w.jpg" data-caption="" data-size="normal" data-rawwidth="460" data-rawheight="270" class="origin_image zh-lightbox-thumb lazy" width="460" data-original="https://pic4.zhimg.com/v2-f8ed385f32a517c784bce841e6da1daf_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-f8ed385f32a517c784bce841e6da1daf_b.jpg" data-lazy-status="ok"></figure><p class="ztext-empty-paragraph"><br></p><h2>交叉熵损失 Cross Entropy Loss</h2><p>上文介绍的几种损失函数都是适用于回归问题损失函数，对于分类问题，最常用的损失函数是交叉熵损失函数 <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Cross_entropy" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">Cross Entropy Loss</a>。</p><h3>二分类</h3><p>考虑二分类，在二分类中我们通常使用 <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Sigmoid_function" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">Sigmoid</a> 函数将模型的输出压缩到 (0, 1) 区间内  <img src="https://www.zhihu.com/equation?tex=%5Chat%7By_i%7D+%5Cin+%280%2C+1%29" alt="[公式]" eeimg="1" data-formula="\hat{y_i} \in (0, 1)"> ，用来代表给定输入 <img src="https://www.zhihu.com/equation?tex=x_i" alt="[公式]" eeimg="1" data-formula="x_i"> ，模型判断为正类的概率。由于只有正负两类，因此同时也得到了负类的概率。</p><p><img src="https://www.zhihu.com/equation?tex=p%28y_i%3D1%7Cx_i%29+%3D+%5Chat%7By_i%7D%5C%5C+++p%28y_i%3D0%7Cx_i%29+%3D+1-%5Chat%7By_i%7D++%5C%5C" alt="[公式]" eeimg="1" data-formula="p(y_i=1|x_i) = \hat{y_i}\\   p(y_i=0|x_i) = 1-\hat{y_i}  \\"></p><p>将两条式子合并成一条</p><p><img src="https://www.zhihu.com/equation?tex=p%28y_i%7Cx_i%29+%3D+%28%5Chat%7By_i%7D%29%5E%7By_i%7D+%281-%5Chat%7By_i%7D%29%5E%7B1-y_i%7D+%5C%5C" alt="[公式]" eeimg="1" data-formula="p(y_i|x_i) = (\hat{y_i})^{y_i} (1-\hat{y_i})^{1-y_i} \\"> </p><p>假设数据点之间独立同分布，则似然可以表示为</p><p><img src="https://www.zhihu.com/equation?tex=L%28x%2C+y%29%3D%5Cprod_%7Bi%3D1%7D%5EN%28%5Chat%7By_i%7D%29%5E%7By_i%7D+%281-%5Chat%7By_i%7D%29%5E%7B1-y_i%7D+%5C%5C" alt="[公式]" eeimg="1" data-formula="L(x, y)=\prod_{i=1}^N(\hat{y_i})^{y_i} (1-\hat{y_i})^{1-y_i} \\"> </p><p>对似然取对数，然后加负号变成最小化负对数似然，即为交叉熵损失函数的形式</p><p><img src="https://www.zhihu.com/equation?tex=NLL%28x%2C+y%29%3DJ_%7BCE%7D%3D-%5Csum_%7Bi%3D1%7D%5ENy_i%5Cmathbb%7Blog%28%7D%5Chat%7By_i%7D%29+%2B+%281-+y_i%29%5Cmathbb%7Blog%7D%281-%5Chat%7By_i%7D%29+%5C%5C" alt="[公式]" eeimg="1" data-formula="NLL(x, y)=J_{CE}=-\sum_{i=1}^Ny_i\mathbb{log(}\hat{y_i}) + (1- y_i)\mathbb{log}(1-\hat{y_i}) \\"> </p><p>下图是对二分类的交叉熵损失函数的可视化，蓝线是目标值为 0 时输出不同输出的损失，黄线是目标值为 1 时的损失。可以看到约接近目标值损失越小，随着误差变差，损失呈指数增长。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-7e7732b869d7334c2c960c1089b13439_b.jpg" data-caption="" data-size="normal" data-rawwidth="445" data-rawheight="272" class="origin_image zh-lightbox-thumb" width="445" data-original="https://pic2.zhimg.com/v2-7e7732b869d7334c2c960c1089b13439_r.jpg"/></noscript><img src="https://pic2.zhimg.com/80/v2-7e7732b869d7334c2c960c1089b13439_1440w.jpg" data-caption="" data-size="normal" data-rawwidth="445" data-rawheight="272" class="origin_image zh-lightbox-thumb lazy" width="445" data-original="https://pic2.zhimg.com/v2-7e7732b869d7334c2c960c1089b13439_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-7e7732b869d7334c2c960c1089b13439_b.jpg" data-lazy-status="ok"></figure><p class="ztext-empty-paragraph"><br></p><h3>多分类</h3><p>在多分类的任务中，交叉熵损失函数的推导思路和二分类是一样的，变化的地方是真实值  <img src="https://www.zhihu.com/equation?tex=y_i" alt="[公式]" eeimg="1" data-formula="y_i">  现在是一个 One-hot 向量，同时模型输出的压缩由原来的 Sigmoid 函数换成 <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Softmax_function" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">Softmax</a> 函数。Softmax 函数将每个维度的输出范围都限定在 <img src="https://www.zhihu.com/equation?tex=%280%2C+1%29" alt="[公式]" eeimg="1" data-formula="(0, 1)"> 之间，同时所有维度的输出和为 1，用于表示一个概率分布。</p><p><img src="https://www.zhihu.com/equation?tex=p%28y_i%7Cx_i%29+%3D+%5Cprod_%7Bk%3D1%7D%5EK%28%5Chat%7By_i%5Ek%7D%29%5E%7By_i%5Ek%7D+%5C%5C" alt="[公式]" eeimg="1" data-formula="p(y_i|x_i) = \prod_{k=1}^K(\hat{y_i^k})^{y_i^k} \\"> </p><p>其中 <img src="https://www.zhihu.com/equation?tex=k+%5Cin+K" alt="[公式]" eeimg="1" data-formula="k \in K"> 表示 K 个类别中的一类，同样的假设数据点之间独立同分布，可得到负对数似然为</p><p><img src="https://www.zhihu.com/equation?tex=NLL%28x%2C+y%29+%3D+J_%7BCE%7D+%3D+-%5Csum_%7Bi%3D1%7D%5EN%5Csum_%7Bk%3D1%7D%5EK+y_i%5Ek+%5Cmathbb%7Blog%7D%28%5Chat%7By_i%5Ek%7D%29+%5C%5C" alt="[公式]" eeimg="1" data-formula="NLL(x, y) = J_{CE} = -\sum_{i=1}^N\sum_{k=1}^K y_i^k \mathbb{log}(\hat{y_i^k}) \\"> </p><p>由于  <img src="https://www.zhihu.com/equation?tex=y_i" alt="[公式]" eeimg="1" data-formula="y_i">  是一个 one-hot 向量，除了目标类为 1 之外其他类别上的输出都为 0，因此上式也可以写为</p><p><img src="https://www.zhihu.com/equation?tex=J_%7BCE%7D+%3D+-%5Csum_%7Bi%3D1%7D%5EN+y_i%5E%7Bc_i%7D%5Cmathbb%7Blog%7D%28%5Chat%7By_i%5E%7Bc_i%7D%7D%29+%5C%5C" alt="[公式]" eeimg="1" data-formula="J_{CE} = -\sum_{i=1}^N y_i^{c_i}\mathbb{log}(\hat{y_i^{c_i}}) \\"> </p><p>其中  <img src="https://www.zhihu.com/equation?tex=c_i" alt="[公式]" eeimg="1" data-formula="c_i">  是样本 <img src="https://www.zhihu.com/equation?tex=x_i" alt="[公式]" eeimg="1" data-formula="x_i"> 的目标类。通常这个应用于多分类的交叉熵损失函数也被称为 Softmax Loss 或者 Categorical Cross Entropy Loss。</p><p class="ztext-empty-paragraph"><br></p><h3>Cross Entropy is good. But WHY？</h3><p>分类中为什么不用均方差损失？上文在介绍均方差损失的时候讲到实际上均方差损失假设了误差服从高斯分布，在分类任务下这个假设没办法被满足，因此效果会很差。为什么是交叉熵损失呢？有两个角度可以解释这个事情，一个角度从最大似然的角度，也就是我们上面的推导；另一个角度是可以用信息论来解释交叉熵损失：</p><p>假设对于样本  <img src="https://www.zhihu.com/equation?tex=x_i" alt="[公式]" eeimg="1" data-formula="x_i">  存在一个最优分布  <img src="https://www.zhihu.com/equation?tex=y_i%5E%7B%5Cstar%7D" alt="[公式]" eeimg="1" data-formula="y_i^{\star}">  真实地表明了这个样本属于各个类别的概率，那么我们希望模型的输出 <img src="https://www.zhihu.com/equation?tex=%5Chat%7By_i%7D" alt="[公式]" eeimg="1" data-formula="\hat{y_i}"> 尽可能地逼近这个最优分布，在信息论中，我们可以使用 KL 散度 <a href="https://zhuanlan.zhihu.com/p/77686118/%5Bhttps://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence%5D(https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence)" class="internal" data-za-detail-view-id="1043">Kullback–Leibler Divergence</a> 来衡量两个分布的相似性。给定分布 <img src="https://www.zhihu.com/equation?tex=p" alt="[公式]" eeimg="1" data-formula="p"> 和分布  <img src="https://www.zhihu.com/equation?tex=q" alt="[公式]" eeimg="1" data-formula="q"> ， 两者的 KL 散度公式如下</p><p><img src="https://www.zhihu.com/equation?tex=+KL%28p%2C+q%29%3D%5Csum_%7Bk%3D1%7D%5EKp%5Cmathbb%7Blog%7D%28p%29+-+%5Csum_%7Bk%3D1%7D%5EKp%5Cmathbb%7Blog%7D%28q%29+%5C%5C" alt="[公式]" eeimg="1" data-formula=" KL(p, q)=\sum_{k=1}^Kp\mathbb{log}(p) - \sum_{k=1}^Kp\mathbb{log}(q) \\"> </p><p>其中第一项为分布 <img src="https://www.zhihu.com/equation?tex=p" alt="[公式]" eeimg="1" data-formula="p"> 的信息熵，第二项为分布 <img src="https://www.zhihu.com/equation?tex=p" alt="[公式]" eeimg="1" data-formula="p"> 和 <img src="https://www.zhihu.com/equation?tex=q" alt="[公式]" eeimg="1" data-formula="q"> 的交叉熵。将最优分布  <img src="https://www.zhihu.com/equation?tex=y_i%5E%7B%5Cstar%7D" alt="[公式]" eeimg="1" data-formula="y_i^{\star}">  和输出分布  <img src="https://www.zhihu.com/equation?tex=%5Chat%7By_i%7D" alt="[公式]" eeimg="1" data-formula="\hat{y_i}">  带入 <img src="https://www.zhihu.com/equation?tex=p" alt="[公式]" eeimg="1" data-formula="p"> 和  <img src="https://www.zhihu.com/equation?tex=q" alt="[公式]" eeimg="1" data-formula="q">  得到</p><p><img src="https://www.zhihu.com/equation?tex=KL%28y_i%5E%7B%5Cstar%7D%2C+%5Chat%7By_i%7D%29%3D%5Csum_%7Bk%3D1%7D%5EKy_i%5E%7B%5Cstar%7D%5Cmathbb%7Blog%7D%28y_i%5E%7B%5Cstar%7D%29+-+%5Csum_%7Bk%3D1%7D%5EKy_i%5E%7B%5Cstar%7D%5Cmathbb%7Blog%7D%28%5Chat%7By_i%7D%29+%5C%5C" alt="[公式]" eeimg="1" data-formula="KL(y_i^{\star}, \hat{y_i})=\sum_{k=1}^Ky_i^{\star}\mathbb{log}(y_i^{\star}) - \sum_{k=1}^Ky_i^{\star}\mathbb{log}(\hat{y_i}) \\"> </p><p>由于我们希望两个分布尽量相近，因此我们最小化 KL 散度。同时由于上式第一项信息熵仅与最优分布本身相关，因此我们在最小化的过程中可以忽略掉，变成最小化</p><p><img src="https://www.zhihu.com/equation?tex=%5Csum_%7Bk%3D1%7D%5EKy_i%5E%7B%5Cstar%7D%5Cmathbb%7Blog%7D%28%5Chat%7By_i%7D%29+%5C%5C" alt="[公式]" eeimg="1" data-formula="\sum_{k=1}^Ky_i^{\star}\mathbb{log}(\hat{y_i}) \\"> </p><p>我们并不知道最优分布 <img src="https://www.zhihu.com/equation?tex=y_i%5E%7B%5Cstar%7D" alt="[公式]" eeimg="1" data-formula="y_i^{\star}"> ，但训练数据里面的目标值  <img src="https://www.zhihu.com/equation?tex=y_i" alt="[公式]" eeimg="1" data-formula="y_i">  可以看做是 <img src="https://www.zhihu.com/equation?tex=y_i%5E%7B%5Cstar%7D" alt="[公式]" eeimg="1" data-formula="y_i^{\star}"> 的一个近似分布</p><p><img src="https://www.zhihu.com/equation?tex=-+%5Csum_%7Bk%3D1%7D%5EKy_i%5Cmathbb%7Blog%7D%28%5Chat%7By_i%7D%29+%5C%5C" alt="[公式]" eeimg="1" data-formula="- \sum_{k=1}^Ky_i\mathbb{log}(\hat{y_i}) \\"> </p><p>这个是针对单个训练样本的损失函数，如果考虑整个数据集，则</p><p><img src="https://www.zhihu.com/equation?tex=J_%7BKL%7D+%3D+-%5Csum_%7Bi%3D1%7D%5EN%5Csum_%7Bk%3D1%7D%5EK+y_i%5Ek+%5Cmathbb%7Blog%7D%28%5Chat%7By_i%5Ek%7D%29%3D-%5Csum_%7Bi%3D1%7D%5EN+y_i%5E%7Bc_i%7D%5Cmathbb%7Blog%7D%28%5Chat%7By_i%5E%7Bc_i%7D%7D%29+%5C%5C" alt="[公式]" eeimg="1" data-formula="J_{KL} = -\sum_{i=1}^N\sum_{k=1}^K y_i^k \mathbb{log}(\hat{y_i^k})=-\sum_{i=1}^N y_i^{c_i}\mathbb{log}(\hat{y_i^{c_i}}) \\"> </p><p>可以看到<b>通过最小化交叉熵的角度推导出来的结果和使用最大  化似然得到的结果是一致的</b>。</p><p class="ztext-empty-paragraph"><br></p><h2>合页损失  Hinge Loss</h2><p>合页损失 <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Hinge_loss" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">Hinge Loss</a> 是另外一种二分类损失函数，适用于 maximum-margin 的分类，支持向量机 Support Vector Machine (SVM) 模型的损失函数本质上就是 Hinge Loss + L2 正则化。合页损失的公式如下</p><p><img src="https://www.zhihu.com/equation?tex=J_%7Bhinge%7D%3D%5Csum_%7Bi%3D1%7D%5EN%5Coperatorname%7Bmax%7D%5Cleft%280%2C+1-%5Cmathbb%7Bsgn%7D%28y_i%29%5Chat%7By_i%7D%5Cright%29++%5C%5C" alt="[公式]" eeimg="1" data-formula="J_{hinge}=\sum_{i=1}^N\operatorname{max}\left(0, 1-\mathbb{sgn}(y_i)\hat{y_i}\right)  \\"> </p><p>下图是  <img src="https://www.zhihu.com/equation?tex=y" alt="[公式]" eeimg="1" data-formula="y">  为正类， 即 <img src="https://www.zhihu.com/equation?tex=%5Cmathbb%7Bsgn%7D%28y%29+%3D+1" alt="[公式]" eeimg="1" data-formula="\mathbb{sgn}(y) = 1"> 时，不同输出的合页损失示意图</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-678fe676ad9dfd82d943eea56da26ecf_b.jpg" data-caption="" data-size="normal" data-rawwidth="430" data-rawheight="274" class="origin_image zh-lightbox-thumb" width="430" data-original="https://pic4.zhimg.com/v2-678fe676ad9dfd82d943eea56da26ecf_r.jpg"/></noscript><img src="https://pic4.zhimg.com/80/v2-678fe676ad9dfd82d943eea56da26ecf_1440w.jpg" data-caption="" data-size="normal" data-rawwidth="430" data-rawheight="274" class="origin_image zh-lightbox-thumb lazy" width="430" data-original="https://pic4.zhimg.com/v2-678fe676ad9dfd82d943eea56da26ecf_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-678fe676ad9dfd82d943eea56da26ecf_b.jpg" data-lazy-status="ok"></figure><p>可以看到当 <img src="https://www.zhihu.com/equation?tex=y" alt="[公式]" eeimg="1" data-formula="y"> 为正类时，模型输出负值会有较大的惩罚，当模型输出为正值且在 <img src="https://www.zhihu.com/equation?tex=%280%2C+1%29" alt="[公式]" eeimg="1" data-formula="(0, 1)"> 区间时还会有一个较小的惩罚。即合页损失不仅惩罚预测错的，并且对于预测对了但是置信度不高的也会给一个惩罚，只有置信度高的才会有零损失。使用合页损失直觉上理解是要<b>找到一个决策边界，使得所有数据点被这个边界正确地、高置信地被分类</b>。</p><p class="ztext-empty-paragraph"><br></p><h2>总结</h2><p>本文针对机器学习中最常用的几种损失函数进行相关介绍，首先是适用于回归的均方差损失 Mean Squared Loss、平均绝对误差损失 Mean Absolute Error Loss，两者的区别以及两者相结合得到的 Huber Loss，接着是应用于分位数回归的分位数损失 Quantile Loss，表明了平均绝对误差损失实际上是分位数损失的一种特例，在分类场景下，本文讨论了最常用的交叉熵损失函数 Cross Entropy Loss，包括二分类和多分类下的形式，并从信息论的角度解释了交叉熵损失函数，最后简单介绍了应用于 SVM 中的 Hinge 损失 Hinge Loss。本文相关的可视化代码在 <a href="https://link.zhihu.com/?target=https%3A//github.com/borgwang/toys/tree/master/loss_functions" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">这里</a>。</p><p>受限于时间，本文还有其他许多损失函数没有提及，比如应用于 Adaboost 模型中的指数损失 Exponential Loss，0-1 损失函数等。另外通常在损失函数中还会有正则项（L1/L2 正则），这些正则项作为损失函数的一部分，通过约束参数的绝对值大小以及增加参数稀疏性来降低模型的复杂度，防止模型过拟合，这部分内容在本文中也没有详细展开。读者有兴趣可以查阅相关的资料进一步了解。That’s all. Thanks for reading.🤘</p><hr><h2>参考资料</h2><ul><li><a href="https://link.zhihu.com/?target=https%3A//www.cs.ubc.ca/~murphyk/MLbook/" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">Machine Learning: A Probabilistic Perspective</a></li><li><a href="https://link.zhihu.com/?target=https%3A//rohanvarma.me/Loss-Functions/" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">Picking Loss Functions - A comparison between MSE, Cross Entropy, and Hinge Loss</a></li><li><a href="https://link.zhihu.com/?target=https%3A//heartbeat.fritz.ai/5-regression-loss-functions-all-machine-learners-should-know-4fb140e9d4b0" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">5 Regression Loss Functions All Machine Learners Should Know</a></li><li><a href="https://link.zhihu.com/?target=https%3A//gist.github.com/borgwang/4313e9375ef233c3b812f9f80f1af2bb" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">Quantile Regression Demo</a><br> </li></ul><p></p></div>
